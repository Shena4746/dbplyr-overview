[["index.html", "dbplyr 概論. 1 dbplyr とは 1.1 概要 1.2 Pros &amp; Cons 1.3 標準的な作業フロー 2 Hands-on 2.1 R から DB への接続 2.2 テーブルへの参照とクエリの実行 2.3 SQL 文の取得 2.4 翻訳できない R 関数例 2.5 データのダウンロード 2.6 データのアップロード 3 References: dbplyr, DBI, RPostgres 参考資料", " dbplyr 概論. Shena 2022-07-13 1 dbplyr とは 1.1 概要 dbplyr とは, dplyr が DB からデータを得て加工処理を行う際にバックエンドとして働くパッケージ. dbplyr が影で働いてくれるおかげで, DB 上のデータを手元にダウンロードしていないにも関わらず, あたかも手元にあるかのように, 手慣れた dplyr の文法でデータ加工処理を行うことができる. dbplyr は, dplyr の文法で書いたデータ加工処理を接続先の DBMS に合わせた適切な SQL クエリに翻訳する. 翻訳されたクエリは DB との通信を担当する DBI (Database Interface) パッケージを通して実行され, その実行結果は参照としてローカルに返される. これは, SQL の実行結果が常に実データとして手元にダウンロードされる DBI とは対照的である. たとえば, R042 - dbplyrでデータサイエンス100本ノック は見た目は普通の R コードだが, SQL に翻訳されてサーバー側で実行され, その結果は参照として返されている. そのため, テーブルの表示が通常の tibble などと少しだけ異なる. このように, 翻訳が上手く働く限り, dbplyr を意識する必要はほとんどなく, dplyr だと思って書くことができる. 以下は, dbplyr を利用する際の典型的な作業フローの概要. サンプルコードはHands-on ですぐフォローする. 1.2 Pros &amp; Cons 直接 SQL を書くのではなく dbplyr を使う長所と短所を整理しておく. 長所 R - SQL 間の, いわゆる言語またぎが減る SQL の方言に関わらず, dplyr による統一的な書き方ができる 多くの場合, コードがより簡潔になる 短所 SQL に比べて(ユーザーと?)文献が少ない 新たに利用するパッケージについて学習コストが発生する dbplyr, DBI などのパッケージ自体の学習 dbplyr が翻訳可能な R コードの分類 また, 翻訳不可能なコードが存在すること, つまり, dplyr は, SQL の完全な代替物ではないことも指摘しておく. たとえば, base::quantile は非常に限定的なケースでしか翻訳できないし, dplyr::group_modify は全く翻訳不可能である. 1.3 標準的な作業フロー 教科書的なフローは以下のようになる. 接続: DBI と 接続先 DBMS に対応した専用パッケージ (e.g., RPostgres, RSQLite) で接続を確立. テーブルへの参照取得: 接続した DB 上のテーブルへの参照を取得. 処理内容の作成: 参照先のテーブルに対して, dplyr の文法でデータ加工処理を書く. SQLへの翻訳 (自動実行): dbplyr がその処理内容を SQL に変換する. SQL の実行 (自動実行): DBI 等のバックエンドパッケージがその SQL を実行し, 結果への参照を返す. 処理済テーブルの作成(任意): 加工を終えたデータを新たなテーブルとして DB に書き込む. しかし, 現実には Pros &amp; Cons で言及した翻訳問題に直面することが多々ある. その際は, サイズが十分小さくなるまで加工したデータをローカルマシンにダウンロードし, 通常の R での加工処理に帰着させる方法をよく取る. この場合, 上述の作業フローに以下が追加される. データのダウンロード: DB 上のデータを dplyr で手元にダウンロードする. ローカルでのデータ加工: ダウンロードデータを通常のローカルデータとしてさらに加工する. パッケージ含め任意のR関数が自由に使える. データのアップロード (任意): ローカルでの加工を終えたデータを DB 上にアップロードする. もちろん, これは R 上で作業を続けるという場合のフローである. そうではなく, SQL で書くことに切り替えるという選択肢も当然存在する. なお, 本稿では詳しく触れないが, dbplyr, DBI には R 上から SQL を発行して実行するメソッドも存在する. 必要に応じてそれらの公式ドキュメントを参照されたい. 2 Hands-on 標準的な作業フロー に沿って, そのコード例を示す. データは, データサイエンス100本ノック（構造化データ加工編） のものを使い, Postgres DB がどこかに立ててあると仮定する. 途中で DBI のメソッドがたまに出てくるが, それについてはここでは深入りしない. 必要に応じて参考文献にある DBI の関連情報にあたって欲しい. 2.1 R から DB への接続 Introduction to dbplyr 記載の方法に従う. 必須パッケージ達. 最初の2つは DB への接続用. R.version.string # R version ## [1] &quot;R version 4.2.0 (2022-04-22)&quot; packageVersion(&quot;RPostgres&quot;) ## [1] &#39;1.4.4.9000&#39; packageVersion(&quot;DBI&quot;) ## [1] &#39;1.1.3&#39; packageVersion(&quot;dbplyr&quot;) # automatically loaded ## [1] &#39;2.2.1&#39; packageVersion(&quot;dplyr&quot;) ## [1] &#39;1.0.9&#39; まだしてなければ, bash を叩いて Postgres を起動. sudo service postgresql start Introduction to dbplyr は, DB 接続のためのコードとして以下の例と注意を述べている: con &lt;- DBI::dbConnect( drv = RPostgreSQL::PostgreSQL(), host = &quot;database.rstudio.com&quot;, user = &quot;your-name&quot;, password = rstudioapi::askForPassword(&quot;Database password&quot;) ) If you’re not using RStudio, you’ll need some other way to securely retrieve your password. You should never record it in your analysis scripts or type it into the console. Securing Credentials provides some best practices. これを踏まえると, 以下の接続方法は大変行儀が悪いが, 今回はどうせ localhost にこのノック限定で立てている DB だろうから, ここでは咎めないことにする. con &lt;- DBI::dbConnect( drv = RPostgres::Postgres(), host = &quot;localhost&quot;, port = 5432, dbname = &quot;your-database-name&quot;, user = &quot;your-user&quot;, password = &quot;your-password&quot; ) 接続できたか確認. DBI::dbListTables(con) ## [1] &quot;customer&quot; &quot;category&quot; &quot;geocode&quot; &quot;product&quot; &quot;receipt&quot; &quot;store&quot; 2.2 テーブルへの参照とクエリの実行 まずは, DB 上のテーブルへの参照を取得しよう. receipt_tbl &lt;- dplyr::tbl(con, &quot;receipt&quot;) receipt_tbl %&gt;% class() ## [1] &quot;tbl_PqConnection&quot; &quot;tbl_dbi&quot; &quot;tbl_sql&quot; &quot;tbl_lazy&quot; ## [5] &quot;tbl&quot; このオブジェクトは, 実データとしての tibble ではなく, tbl_dbi オブジェクトである. dbplyr の文脈では tbl_lazy と呼ばれることも多いようだ. このtbl_lazyは実データではないが, 実データであるかのように加工処理を受け取って実行してくれる. receipt_1000 &lt;- receipt_tbl %&gt;% filter(amount &gt;= 1000) receipt_1000 %&gt;% class() ## [1] &quot;tbl_PqConnection&quot; &quot;tbl_dbi&quot; &quot;tbl_sql&quot; &quot;tbl_lazy&quot; ## [5] &quot;tbl&quot; receipt_1000 ## # Source: SQL [?? x 9] ## # Database: postgres [guest@localhost:5432/knock100] ## sales_ymd sales_epoch store_cd receipt_no receipt_sub_no customer_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 20181225 1545696000 S13020 1172 2 ZZ000000000000 ## 2 20180911 1536624000 S13018 1122 2 CS018205000001 ## 3 20170501 1493596800 S13004 1192 2 CS004415000232 ## 4 20170523 1495497600 S14028 1182 2 CS028415000203 ## 5 20180310 1520640000 S14028 112 1 ZZ000000000000 ## 6 20170516 1494892800 S14023 1102 1 CS023415000240 ## 7 20190615 1560556800 S13039 1102 2 CS039415000129 ## 8 20180610 1528588800 S13001 1162 2 CS001415000472 ## 9 20170906 1504656000 S13032 1122 2 ZZ000000000000 ## 10 20180819 1534636800 S13019 112 2 CS019215000046 ## # … with more rows, and 3 more variables: product_cd &lt;chr&gt;, quantity &lt;int&gt;, ## # amount &lt;int&gt; このとき返されるのは, 入力元と同じ tbl_lazy である. なお, この例のように, tbl_lazy は head() を使わなくても自動的に数行の情報を返す. 2.3 SQL 文の取得 R から SQL への翻訳パートにも触れておこう. 先述のように, この翻訳過程は自動的に実行されるため初心者が意識する必要はあまりない. ここはスキップしても構わない. R 上の加工処理がどのような SQL クエリに翻訳されたかは dbplyr::show_query() によって調べることができる. receipt_tbl %&gt;% mutate(amount_mean = amount %&gt;% mean(na.rm = TRUE)) %&gt;% filter(amount &gt;= amount_mean) %&gt;% dplyr::show_query() ## &lt;SQL&gt; ## SELECT * ## FROM ( ## SELECT *, AVG(&quot;amount&quot;) OVER () AS &quot;amount_mean&quot; ## FROM &quot;receipt&quot; ## ) &quot;q01&quot; ## WHERE (&quot;amount&quot; &gt;= &quot;amount_mean&quot;) # total amount of purchase per customer_id receipt_tbl %&gt;% group_by(customer_id) %&gt;% summarise(amount = amount %&gt;% sum(na.rm = TRUE)) %&gt;% dplyr::show_query() ## &lt;SQL&gt; ## SELECT &quot;customer_id&quot;, SUM(&quot;amount&quot;) AS &quot;amount&quot; ## FROM &quot;receipt&quot; ## GROUP BY &quot;customer_id&quot; # number of NA on each column con %&gt;% tbl(&quot;product&quot;) %&gt;% summarise( across( .cols = everything(), .fns = ~ if_else(is.na(.x), 1, 0) %&gt;% sum(), .names = &quot;{.col}_NA&quot; ) ) %&gt;% dplyr::show_query() ## &lt;SQL&gt; ## SELECT ## SUM(CASE WHEN ((&quot;product_cd&quot; IS NULL)) THEN 1.0 WHEN NOT ((&quot;product_cd&quot; IS NULL)) THEN 0.0 END) AS &quot;product_cd_NA&quot;, ## SUM(CASE WHEN ((&quot;category_major_cd&quot; IS NULL)) THEN 1.0 WHEN NOT ((&quot;category_major_cd&quot; IS NULL)) THEN 0.0 END) AS &quot;category_major_cd_NA&quot;, ## SUM(CASE WHEN ((&quot;category_medium_cd&quot; IS NULL)) THEN 1.0 WHEN NOT ((&quot;category_medium_cd&quot; IS NULL)) THEN 0.0 END) AS &quot;category_medium_cd_NA&quot;, ## SUM(CASE WHEN ((&quot;category_small_cd&quot; IS NULL)) THEN 1.0 WHEN NOT ((&quot;category_small_cd&quot; IS NULL)) THEN 0.0 END) AS &quot;category_small_cd_NA&quot;, ## SUM(CASE WHEN ((&quot;unit_price&quot; IS NULL)) THEN 1.0 WHEN NOT ((&quot;unit_price&quot; IS NULL)) THEN 0.0 END) AS &quot;unit_price_NA&quot;, ## SUM(CASE WHEN ((&quot;unit_cost&quot; IS NULL)) THEN 1.0 WHEN NOT ((&quot;unit_cost&quot; IS NULL)) THEN 0.0 END) AS &quot;unit_cost_NA&quot; ## FROM &quot;product&quot; この翻訳結果を文字列として得るには show_query() ではなく, dbplyr::sql_render() を使う. # show_query() does not work as intended str_query &lt;- receipt_tbl %&gt;% filter(amount &gt;= 1000) %&gt;% dplyr::show_query() ## &lt;SQL&gt; ## SELECT * ## FROM &quot;receipt&quot; ## WHERE (&quot;amount&quot; &gt;= 1000.0) str_query %&gt;% print() ## # Source: SQL [?? x 9] ## # Database: postgres [guest@localhost:5432/knock100] ## sales_ymd sales_epoch store_cd receipt_no receipt_sub_no customer_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 20181225 1545696000 S13020 1172 2 ZZ000000000000 ## 2 20180911 1536624000 S13018 1122 2 CS018205000001 ## 3 20170501 1493596800 S13004 1192 2 CS004415000232 ## 4 20170523 1495497600 S14028 1182 2 CS028415000203 ## 5 20180310 1520640000 S14028 112 1 ZZ000000000000 ## 6 20170516 1494892800 S14023 1102 1 CS023415000240 ## 7 20190615 1560556800 S13039 1102 2 CS039415000129 ## 8 20180610 1528588800 S13001 1162 2 CS001415000472 ## 9 20170906 1504656000 S13032 1122 2 ZZ000000000000 ## 10 20180819 1534636800 S13019 112 2 CS019215000046 ## # … with more rows, and 3 more variables: product_cd &lt;chr&gt;, quantity &lt;int&gt;, ## # amount &lt;int&gt; # sql_render() works str_query &lt;- receipt_tbl %&gt;% filter(amount &gt;= 1000) %&gt;% dbplyr::sql_render() str_query %&gt;% print() ## &lt;SQL&gt; SELECT * ## FROM &quot;receipt&quot; ## WHERE (&quot;amount&quot; &gt;= 1000.0) こうして翻訳された SQL クエリは DBI パッケージを通して実行される. DBI パッケージについては References の文献を参照. なお, 後述する collect() を挟んだデータをこれらのメソッドに与えるとエラーになる. receipt_tbl %&gt;% summarise(n()) %&gt;% collect() %&gt;% show_query() # error. can&#39;t trace back to a remote table ## Error in UseMethod(&quot;show_query&quot;): no applicable method for &#39;show_query&#39; applied to an object of class &quot;c(&#39;tbl_df&#39;, &#39;tbl&#39;, &#39;data.frame&#39;)&quot; DB 上のテーブルとの関連を失ったデータを得る方法を SQL で表すことはできないという自然な挙動だ. 2.4 翻訳できない R 関数例 実データではないので, tbl_dbi %&gt;% nrow() は常に NA になる. receipt_tbl %&gt;% nrow() ## [1] NA これは代わりに, count() あるいは summarise() で数えてもらえばよい. これらは dbplyr を通しても使える. receipt_tbl %&gt;% count() ## # Source: SQL [1 x 1] ## # Database: postgres [guest@localhost:5432/knock100] ## n ## &lt;int64&gt; ## 1 104681 receipt_tbl %&gt;% summarise(n()) ## # Source: SQL [1 x 1] ## # Database: postgres [guest@localhost:5432/knock100] ## `n()` ## &lt;int64&gt; ## 1 104681 dbplyr 越しでは使えないメソッドもある. たとえば, quantile は summarise 以外では使えない. # cause error receipt_tbl %&gt;% mutate(amount_quan1 = amount %&gt;% quantile(probs = 0.25)) %&gt;% head() ## Error: Failed to prepare query: ERROR: OVER is not supported for ordered-set aggregate percentile_cont ## LINE 3: PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY &quot;amount&quot;) OVE... ## ^ # quantile works under summarise method receipt_tbl %&gt;% summarise(amount_quan1 = amount %&gt;% quantile(probs = 0.25)) %&gt;% head() ## # Source: SQL [1 x 1] ## # Database: postgres [guest@localhost:5432/knock100] ## amount_quan1 ## &lt;dbl&gt; ## 1 102 2.5 データのダウンロード 実行結果を実データとして手元にダウンロードするには, dplyr::collect() を使うのが基本. これを実行した時点で DB との関連は切れて, ローカルの独立したデータとなる. receipt_tbl %&gt;% count() %&gt;% collect() # donwload data ## # A tibble: 1 × 1 ## n ## &lt;int64&gt; ## 1 104681 見慣れた tibble が落ちてきたことが確認できる. ローカルに持ってくれば翻訳可能性問題は気にしなくてよくなる. receipt_tbl %&gt;% collect() %&gt;% mutate(q1 = amount %&gt;% quantile(probs = 0.25)) %&gt;% head() ## # A tibble: 6 × 10 ## sales_ymd sales_epoch store_cd receipt_no receipt_sub_no customer_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 20181103 1541203200 S14006 112 1 CS006214000001 ## 2 20181118 1542499200 S13008 1132 2 CS008415000097 ## 3 20170712 1499817600 S14028 1102 1 CS028414000014 ## 4 20190205 1549324800 S14042 1132 1 ZZ000000000000 ## 5 20180821 1534809600 S14025 1102 2 CS025415000050 ## 6 20190605 1559692800 S13003 1112 1 CS003515000195 ## # … with 4 more variables: product_cd &lt;chr&gt;, quantity &lt;int&gt;, amount &lt;int&gt;, ## # q1 &lt;dbl&gt; dplyr::pull(.data, var = -1, name = NULL,...) では特定の列をベクトルデータとしてダウンロードできる. これはスカラー値を得たいときに特に便利. receipt_tbl %&gt;% summarise(q1 = amount %&gt;% quantile(probs = 0.25)) %&gt;% pull() ## [1] 102 2.6 データのアップロード collect() とは反対に, DB 側に新たなデータを作成する手段もある. これには3つのシナリオが有り得る. ローカルデータを DB にテーブルとして書き込みたい場合 ローカルデータから tbl_lazy を作りたい場合 tbl_lazy を DB にテーブルとして書き込みたい場合 2.6.1 ローカルデータ -&gt; DB テーブル DBI::dbWriteTable() または DBI::dbCreateTable() + DBI::dbAppendTable() を使うことを勧める. # upload data by writing a table con %&gt;% DBI::dbWriteTable( # upload by writing name = &quot;mtcars&quot;, value = mtcars, overwirte = TRUE ) con %&gt;% DBI::dbListTables() # show remote tables ## [1] &quot;customer&quot; &quot;mtcars&quot; &quot;category&quot; &quot;geocode&quot; &quot;product&quot; &quot;receipt&quot; &quot;store&quot; con %&gt;% tbl(&quot;mtcars&quot;) %&gt;% head() ## # Source: SQL [6 x 11] ## # Database: postgres [guest@localhost:5432/knock100] ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 # by creating a table first and then append the data to it if (con %&gt;% DBI::dbExistsTable(&quot;mtcars&quot;)) { con %&gt;% DBI::dbRemoveTable(&quot;mtcars&quot;) } con %&gt;% DBI::dbCreateTable( name = &quot;mtcars&quot;, fields = mtcars ) con %&gt;% DBI::dbAppendTable( name = &quot;mtcars&quot;, value = mtcars ) ## [1] 32 con %&gt;% DBI::dbListTables() # show remote tables ## [1] &quot;customer&quot; &quot;mtcars&quot; &quot;category&quot; &quot;geocode&quot; &quot;product&quot; &quot;receipt&quot; &quot;store&quot; tbl(con, &quot;mtcars&quot;) %&gt;% head() ## # Source: SQL [6 x 11] ## # Database: postgres [guest@localhost:5432/knock100] ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 con %&gt;% DBI::dbRemoveTable(&quot;mtcars&quot;) 【余談】 DBI は, DBI::dbWriteTable() は一度に色々なことができすぎてしまうため, よりインクリメンタルな DBI::dbCreateTable() と DBI::dbAppendTable() を組み合わせて使う方法を推奨しているらしい(?). 2.6.2 ローカルデータ -&gt; tbl_lazy dbplyr::copy_inline() を使う. これは現在のコネクションが切れれば消滅する一時的な tbl_lazy を作る. mtcars_tbl &lt;- con %&gt;% dbplyr::copy_inline(mtcars) # upload mtcars_tbl %&gt;% class() ## [1] &quot;tbl_PqConnection&quot; &quot;tbl_sql&quot; &quot;tbl_lazy&quot; &quot;tbl&quot; con %&gt;% DBI::dbListTables() # mtcars is not written in as a table ## [1] &quot;customer&quot; &quot;category&quot; &quot;geocode&quot; &quot;product&quot; &quot;receipt&quot; &quot;store&quot; mtcars_tbl %&gt;% head() ## # Source: SQL [6 x 11] ## # Database: postgres [guest@localhost:5432/knock100] ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 当然ながら copy_inline() はどのテーブルも参照していない. 対応する SQL は元データの羅列からの SELECT 文となる. mtcars_tbl %&gt;% show_query() ## &lt;SQL&gt; ## SELECT ## CAST(&quot;mpg&quot; AS NUMERIC) AS &quot;mpg&quot;, ## CAST(&quot;cyl&quot; AS NUMERIC) AS &quot;cyl&quot;, ## CAST(&quot;disp&quot; AS NUMERIC) AS &quot;disp&quot;, ## CAST(&quot;hp&quot; AS NUMERIC) AS &quot;hp&quot;, ## CAST(&quot;drat&quot; AS NUMERIC) AS &quot;drat&quot;, ## CAST(&quot;wt&quot; AS NUMERIC) AS &quot;wt&quot;, ## CAST(&quot;qsec&quot; AS NUMERIC) AS &quot;qsec&quot;, ## CAST(&quot;vs&quot; AS NUMERIC) AS &quot;vs&quot;, ## CAST(&quot;am&quot; AS NUMERIC) AS &quot;am&quot;, ## CAST(&quot;gear&quot; AS NUMERIC) AS &quot;gear&quot;, ## CAST(&quot;carb&quot; AS NUMERIC) AS &quot;carb&quot; ## FROM ( ## VALUES ## (21.0, 6.0, 160.0, 110.0, 3.9, 2.62, 16.46, 0.0, 1.0, 4.0, 4.0), ## (21.0, 6.0, 160.0, 110.0, 3.9, 2.875, 17.02, 0.0, 1.0, 4.0, 4.0), ## (22.8, 4.0, 108.0, 93.0, 3.85, 2.32, 18.61, 1.0, 1.0, 4.0, 1.0), ## (21.4, 6.0, 258.0, 110.0, 3.08, 3.215, 19.44, 1.0, 0.0, 3.0, 1.0), ## (18.7, 8.0, 360.0, 175.0, 3.15, 3.44, 17.02, 0.0, 0.0, 3.0, 2.0), ## (18.1, 6.0, 225.0, 105.0, 2.76, 3.46, 20.22, 1.0, 0.0, 3.0, 1.0), ## (14.3, 8.0, 360.0, 245.0, 3.21, 3.57, 15.84, 0.0, 0.0, 3.0, 4.0), ## (24.4, 4.0, 146.7, 62.0, 3.69, 3.19, 20.0, 1.0, 0.0, 4.0, 2.0), ## (22.8, 4.0, 140.8, 95.0, 3.92, 3.15, 22.9, 1.0, 0.0, 4.0, 2.0), ## (19.2, 6.0, 167.6, 123.0, 3.92, 3.44, 18.3, 1.0, 0.0, 4.0, 4.0), ## (17.8, 6.0, 167.6, 123.0, 3.92, 3.44, 18.9, 1.0, 0.0, 4.0, 4.0), ## (16.4, 8.0, 275.8, 180.0, 3.07, 4.07, 17.4, 0.0, 0.0, 3.0, 3.0), ## (17.3, 8.0, 275.8, 180.0, 3.07, 3.73, 17.6, 0.0, 0.0, 3.0, 3.0), ## (15.2, 8.0, 275.8, 180.0, 3.07, 3.78, 18.0, 0.0, 0.0, 3.0, 3.0), ## (10.4, 8.0, 472.0, 205.0, 2.93, 5.25, 17.98, 0.0, 0.0, 3.0, 4.0), ## (10.4, 8.0, 460.0, 215.0, 3.0, 5.424, 17.82, 0.0, 0.0, 3.0, 4.0), ## (14.7, 8.0, 440.0, 230.0, 3.23, 5.345, 17.42, 0.0, 0.0, 3.0, 4.0), ## (32.4, 4.0, 78.7, 66.0, 4.08, 2.2, 19.47, 1.0, 1.0, 4.0, 1.0), ## (30.4, 4.0, 75.7, 52.0, 4.93, 1.615, 18.52, 1.0, 1.0, 4.0, 2.0), ## (33.9, 4.0, 71.1, 65.0, 4.22, 1.835, 19.9, 1.0, 1.0, 4.0, 1.0), ## (21.5, 4.0, 120.1, 97.0, 3.7, 2.465, 20.01, 1.0, 0.0, 3.0, 1.0), ## (15.5, 8.0, 318.0, 150.0, 2.76, 3.52, 16.87, 0.0, 0.0, 3.0, 2.0), ## (15.2, 8.0, 304.0, 150.0, 3.15, 3.435, 17.3, 0.0, 0.0, 3.0, 2.0), ## (13.3, 8.0, 350.0, 245.0, 3.73, 3.84, 15.41, 0.0, 0.0, 3.0, 4.0), ## (19.2, 8.0, 400.0, 175.0, 3.08, 3.845, 17.05, 0.0, 0.0, 3.0, 2.0), ## (27.3, 4.0, 79.0, 66.0, 4.08, 1.935, 18.9, 1.0, 1.0, 4.0, 1.0), ## (26.0, 4.0, 120.3, 91.0, 4.43, 2.14, 16.7, 0.0, 1.0, 5.0, 2.0), ## (30.4, 4.0, 95.1, 113.0, 3.77, 1.513, 16.9, 1.0, 1.0, 5.0, 2.0), ## (15.8, 8.0, 351.0, 264.0, 4.22, 3.17, 14.5, 0.0, 1.0, 5.0, 4.0), ## (19.7, 6.0, 145.0, 175.0, 3.62, 2.77, 15.5, 0.0, 1.0, 5.0, 6.0), ## (15.0, 8.0, 301.0, 335.0, 3.54, 3.57, 14.6, 0.0, 1.0, 5.0, 8.0), ## (21.4, 4.0, 121.0, 109.0, 4.11, 2.78, 18.6, 1.0, 1.0, 4.0, 2.0) ## ) AS drvd(&quot;mpg&quot;, &quot;cyl&quot;, &quot;disp&quot;, &quot;hp&quot;, &quot;drat&quot;, &quot;wt&quot;, &quot;qsec&quot;, &quot;vs&quot;, &quot;am&quot;, &quot;gear&quot;, &quot;carb&quot;) release_cons() ## [1] &quot;con&quot; con &lt;- issue_con() 2.6.3 tbl_lazy -&gt; DB テーブル dplyr::copy_to() を使う. デフォルトでは, 被る可能性のない変な名前の一時テーブルを作る. デフォルトのネーミングはあんまりなので(試してみるとよい), name = 引数で名前は指定した方がよい. con %&gt;% tbl(&quot;receipt&quot;) %&gt;% filter(amount &gt;= 1000) %&gt;% copy_to( dest = con, df = ., name = &quot;temp&quot;, overwrite = TRUE # optional ) # from tbl_lazy to table con %&gt;% dbListTables() ## [1] &quot;customer&quot; &quot;category&quot; &quot;temp&quot; &quot;geocode&quot; &quot;product&quot; &quot;receipt&quot; &quot;store&quot; con %&gt;% tbl(&quot;temp&quot;) %&gt;% head() ## # Source: SQL [6 x 9] ## # Database: postgres [guest@localhost:5432/knock100] ## sales_ymd sales_epoch store_cd receipt_no receipt_sub_no customer_id ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 20181225 1545696000 S13020 1172 2 ZZ000000000000 ## 2 20180911 1536624000 S13018 1122 2 CS018205000001 ## 3 20170501 1493596800 S13004 1192 2 CS004415000232 ## 4 20170523 1495497600 S14028 1182 2 CS028415000203 ## 5 20180310 1520640000 S14028 112 1 ZZ000000000000 ## 6 20170516 1494892800 S14023 1102 1 CS023415000240 ## # … with 3 more variables: product_cd &lt;chr&gt;, quantity &lt;int&gt;, amount &lt;int&gt; con %&gt;% dbDisconnect() con &lt;- issue_con() con %&gt;% dbListTables() # copied table disappeared ## [1] &quot;customer&quot; &quot;category&quot; &quot;geocode&quot; &quot;product&quot; &quot;receipt&quot; &quot;store&quot; dplyr::copy_to() は, ローカルデータから一時テーブルを作成することもできる. その意味では, DBI::dbWriteTable などと似ている. しかし, 後者で一時テーブルを作る機能がサポートされているかどうかは, DBI のバックエンドパッケージ(e.g., RPostgres, RSQLite) に依存する. 両者の間に, 必ずしも相互互換性はないことには注意すべきであろう. 3 References: dbplyr, DBI, RPostgres 参考資料 Overview 巨大なデータがSQLサーバーにあるときに、Rでどう立ち向かうかマニュアル：dbplyrパッケージを中心として Introduction to dbplyr R: Working with Databases Introduction to DBI DBI RSQLite &amp; DBIの使い方 DBI specification DBI: R Database Interface .pdf Code Examples for DBI and RPostgres User-defined functions that DBI + RPostgres users should have dbplyr 実践問題集 dbplyrでデータサイエンス100本ノック "]]
